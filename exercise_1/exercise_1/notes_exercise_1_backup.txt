# Exercise 1 Notes (step-by-step)

1) Header bootstrap
   - Added `#pragma once` to guard the header.
   - Included `<stdint.h>` for fixed-width integer types.

2) RCC register layout
   - Defined `RCC_TypeDef` with key registers up to `AHB1ENR`.
   - Marked registers `volatile` since hardware can change them outside program control.
   - Notable fields: `CR` (clock control), `PLLCFGR` (PLL config), `CFGR` (clock tree), `AHB1ENR` (clock enables for AHB1 peripherals).

3) RCC base/pointer and clock-enable bit
   - `PERIPH_BASE`/`RCC_BASE` macros for hardware addresses (from RM0090).
   - `RCC` macro casts `RCC_BASE` to `RCC_TypeDef *`.
   - `RCC_AHB1ENR_GPIODEN` bit enables the GPIOD clock (needed before touching GPIO port D for the LED).

4) GPIO register layout and base
   - Added `GPIO_TypeDef` with key registers:
     * MODER: pin mode (00=input, 01=output, 10=alt, 11=analog)
     * OTYPER: push-pull vs open-drain
     * OSPEEDR: output speed/slew
     * PUPDR: pull-up/down
     * IDR/ODR: input/output data
     * BSRR: atomic bit set/reset
     * LCKR/AFR: lock and alternate functions
   - Base macros: `AHB1PERIPH_BASE`, `GPIOD_BASE`, and `GPIOD` pointer to access port D.

Notes on SCB portability (ahead of adding it):
- SCB is ARM-defined (not vendor-specific) and is broadly consistent across Cortex-M cores, but some fields differ:
  * Cortex-M3/M4/M7: has VTOR, SHP[], SHCSR as we’ll define.
  * Cortex-M0/M0+: no VTOR and a reduced SCB (fewer system handler priority registers).
  * Cortex-M33/M23 and later add security/SAU-related registers not in M4.
- Keep the struct matching the target core’s reference manual; don’t copy SCB_Type between architectures without checking.

5) SCB/SysTick (core)
   - `SCB_Type` (Cortex-M4 layout): CPUID (info), ICSR (PendSV trigger), VTOR (vector base), AIRCR (reset/priority grouping), SCR/CCR (sleep/stack align), SHP[12] (system handler priorities for SVC/PendSV/SysTick), SHCSR (fault enables).
   - `SysTick_Type`: CTRL (enable/tickint/clksource), LOAD (reload), VAL (current), CALIB (reference).
   - Base addresses: SCS_BASE 0xE000E000, SysTick_BASE, SCB_BASE. Pointer macros: `SCB`, `SysTick`.
   - SysTick bits: ENABLE, TICKINT, CLKSOURCE (1 = CPU clock).

6) Vector table (Cortex-M) – entries are 32-bit words
   Index | Entry                 | Purpose
   ------+-----------------------+-----------------------------------------
     0   | _estack               | Initial stack pointer (top of RAM)
     1   | Reset_Handler         | Reset entry point
     2   | NMI_Handler           | Non-maskable interrupt
     3   | HardFault_Handler     | Hard fault
     4   | MemManage_Handler     | Memory management fault
     5   | BusFault_Handler      | Bus fault
     6   | UsageFault_Handler    | Usage fault
     7   | 0                     | Reserved
     8   | 0                     | Reserved
     9   | 0                     | Reserved
    10   | 0                     | Reserved
    11   | SVC_Handler           | Supervisor call (SVC)
    12   | DebugMon_Handler      | Debug monitor
    13   | 0                     | Reserved
    14   | PendSV_Handler        | Pendable service call (RTOS context switch)
    15   | SysTick_Handler       | SysTick interrupt (periodic tick)

7) Startup stubs
   - Handlers currently just `b .` (branch to self) to hang; will replace Reset_Handler with real startup (copy .data, zero .bss, call SystemInit/main).

8) Reset_Handler steps (now implemented)
   - Set SP from `_estack`.
   - Call `SystemInit`.
   - Copy `.data`: from `_sidata` (FLASH) to `_sdata.._edata` (RAM).
   - Zero `.bss`: `_sbss.._ebss`.
   - Call `main`; if it returns, loop forever.

Quick ARM assembly notes (see arm_assembly_quick_guide.txt)
   - `.word` is 32-bit.
   - `b .` loops forever.

9) SystemInit/SystemCoreClock (industry-standard CMSIS naming)
   - `SystemCoreClock` holds the current core frequency; CMSIS keeps camel case to match vendor/RTOS expectations.
   - Minimal SystemInit: enable FPU (CPACR bits 20-23), leave clocks at HSI 16 MHz for now.
   - SystemCoreClockUpdate syncs the variable (still 16 MHz).
   - In code: set CPACR (0xE000ED88) bits 20-23 to 0b1111 for CP10/CP11 full access.

10) GPIO block (port D) details
    - Base: PERIPH_BASE 0x4000_0000; AHB1PERIPH_BASE = PERIPH_BASE + 0x20_000 = 0x4002_0000; GPIOD_BASE = AHB1PERIPH_BASE + 0x0C00 = 0x4002_0C00.
    - Register widths: all 32-bit. Bit allocation:
      * MODER: 2 bits/pin (00=in, 01=out, 10=alt, 11=analog) → bits [2n+1:2n].
      * OTYPER: 1 bit/pin (0=push-pull, 1=open-drain) → bit n.
      * OSPEEDR: 2 bits/pin (slew) → bits [2n+1:2n].
      * PUPDR: 2 bits/pin (00=no pull, 01=PU, 10=PD) → bits [2n+1:2n].
      * IDR/ODR: 1 bit/pin read/write → bit n.
      * BSRR: lower 16 bits set pins, upper 16 bits reset pins (atomic).
      * LCKR: lock bits for pins + lock key.
      * AFR[0]: pins 0-7 alt function (4 bits/pin); AFR[1]: pins 8-15.
    - Example PD12 setup: MODER bits 25:24 = 01 (output); OTYPER bit 12 = 0 (push-pull); OSPEEDR bits 25:24 = 10 (medium); PUPDR bits 25:24 = 00 (none).

11) Non-blocking blink via SysTick (main.c)
     - SysTick: 1 kHz tick, ISR increments `sys_tick` (volatile uint32_t).
     - SysTick priority set via `SCB->SHP[11]` (SysTick system handler priority).
     - Main loop uses wrap-safe deadline check: `(int32_t)(sys_tick - next_toggle) >= 0`.
     - Blink state toggled via atomic GPIO writes using BSRR:
         * Set: `BSRR = (1U << pin)`; Reset: `BSRR = (1U << (pin + 16))`.
     - GPIOD init configures pin mode/output type/speed/pull for LED.

12) Linker script gotchas (data LMA)
    - `_sidata` must point to FLASH; set `_sidata = .;` before `.data` and optionally align (`. = ALIGN(4);`) to avoid LMA=0.
    - LMA/VMA: .data loads from FLASH (LMA) to RAM (VMA) at startup; .bss zeroed in RAM.

13) Renode usage (headless)
    - Use correct peripheral names from the .repl: e.g., `gpioPortD`.
    - Analyzer backends require GUI/XWT; in CLI use logging/reads:
        * `sysbus LogPeripheralAccess gpioPortD`
        * `sysbus ReadDoubleWord <addr>` for MMIO (e.g., ODR at 0x40020C14).
    - Use absolute ELF path in .resc to avoid path issues.

14) QEMU notes
    - Mainline QEMU STM32 support is limited; `-M netduinoplus2` is the closest (STM32F405). Use `-d unimp,guest_errors` to see unmodeled peripherals. No GPIO analyzers; Renode is preferred for peripheral visibility.
